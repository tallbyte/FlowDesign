
\newcommand{\depBox}[1]{
	\begin{adjustbox}{minipage=0.85\textwidth,margin=0 \smallskipamount,center}
		Abhängigkeiten:	 \quad #1
	\end{adjustbox} ~\\
}
\newcommand{\refModCore}{\hyperref[mod_core]{Core}}
\newcommand{\refModData}{\hyperref[mod_data]{Data}}
\newcommand{\refModDataUI}{\hyperref[mod_data-ui]{Data-UI}}
\newcommand{\refModJavaFX}{\hyperref[mod_javafx]{JavaFX}}
\newcommand{\refModModel}{\hyperref[mod_model]{Model}}
\newcommand{\refModStorage}{\hyperref[mod_storage]{Storage}}

\section{Module}
\subsection{Modulübersicht}
Die Teilbereiche des Projekts wurden in verschieden Module aufgeteilt:
\begin{figure}[hb!]
	\centering
	\includegraphics[width=.8\textwidth]{module_dependencies.png}
	\caption{Abhängigkeitsgraph der Module}
	\label{mod_dep_view}
\end{figure}

Der in Abbildung \ref{mod_dep_view} gezeigte Graph enthält keine Abhängigkeiten nach JUnit und
dem JDK aus Gründen der Übersicht.

Anzumerken ist auch, dass bis in das Modul \refModCore{} keine Abhängigkeiten
gegenüber einer UI-Bibliothek existieren. Das Modul \hyperref[mod_data-ui]{Data-UI} stellt
zwar Komponenten bereit, die für die Integration in eine Benutzeroberfläche benötigt werden,
bleibt jedoch Benutzeroberflächenunabhängig.


\subsection{Modul Core}
\label{mod_core}
\begin{figure}[hb!]
	\centering
	\includegraphics[width=.8\textwidth]{module_dependencies_core.png}
\end{figure}
\depBox{Data (\ref{mod_data}), Data-UI (\ref{mod_data-ui}), Storage (\ref{mod_storage})}

Modulerklräung hier




\subsection{Modul Data}
\label{mod_data}
\begin{figure}[hb!]
	\centering
	\includegraphics[width=.8\textwidth]{module_dependencies_data.png}
\end{figure}
\depBox{Keine}

Modulerklräung hier




\subsection{Modul Data-UI}
\label{mod_data-ui}
\begin{figure}[hb!]
	\centering
	\includegraphics[width=.8\textwidth]{module_dependencies_data-ui.png}
\end{figure}
\depBox{Keine}

Modulerklräung hier




\subsection{Modul JavaFX}
\label{mod_javafx}
\begin{figure}[hb!]
	\centering
	\includegraphics[width=.8\textwidth]{module_dependencies_javafx.png}
\end{figure}
\depBox{Model (\ref{mod_model}), ControlsFX (ext. \cite{controlsfx})}

Modulerklräung hier




\subsection{Modul Model}
\label{mod_model}
\begin{figure}[hb!]
	\centering
	\includegraphics[width=.8\textwidth]{module_dependencies_model.png}
\end{figure}
\depBox{Core (\ref{mod_core})}

Modulerklräung hier




\subsection{Modul Storage}
\label{mod_storage}
\begin{figure}[hb!]
	\centering
	\includegraphics[width=.8\textwidth]{module_dependencies_storage.png}
\end{figure}
\depBox{Data (\ref{mod_data}), Data-UI (\ref{mod_data-ui})}

Das Storage Modul enthält sowohl eine abstrake Definition von \textit{Serializern} und \textit{StorageHandlern}
als auch eine Implementation für XML inklusive \textit{Serializer} für Komponenten in \refModData{} und
\refModDataUI{}.

\subsubsection{StorageHandler}
Die Klasse \textit{StorageHandler} ist hält \textit{Storage}s und verteilt Serialisierungsaufgaben an
das entsprechende \textit{Storage} anhand eines Textidentifikators (für XML lautet dieser 'xml').
Eine weitere \textit{Storage} Implementation kann anhand eines neuen Textidentifkators registriert werden,
wodurch ein Umstieg von XML auf JSON, SQL oder eine andere Implementation vereinfacht wird.

\subsubsection{Storage}
Ein \textit{Storage} stellt ein Speicherort für alle zum Projekt gehörenden Komponenten dar. Je nach
Implementation kann dies XML (implementiert), JSON, SQL oder andere sein (nicht implementiert). Bei einem
\textit{Storage} können \textit{Serializer} für weitere Komponenten registriert werden. Sowohl Lese- als
auch Schreibhandles und Hilfsklassen für die \textit{Serializer} werden über Generics in \textit{Storage}
definiert.

\subsubsection{Serializer}
Ein \textit{Serializer} hat die Aufgabe eine Komponente zu serialisieren und wieder zu deserialisieren.
Der Umfang eines \textit{Serializer}s sollte sich auf eine Komponente beziehen (siehe \refPrincipleSingleResponsibilityLong).